# c++ 基础高级(上)

- [1. 内存分区模型](#1-内存分区模型)
  - [1.1. 程序运行前](#11-程序运行前)
  - [1.2. 程序运行后](#12-程序运行后)
  - [1.3. new 操作符](#13-new-操作符)
- [2. 引用](#2-引用)
  - [2.1. 引用的基本使用](#21-引用的基本使用)
  - [2.2. 引用做函数参数](#22-引用做函数参数)
  - [2.3. 引用做函数返回值](#23-引用做函数返回值)
  - [2.4. 引用的本质](#24-引用的本质)
  - [2.5. 常量引用](#25-常量引用)
- [3. 函数提高](#3-函数提高)
  - [3.1. 函数默认参数](#31-函数默认参数)
  - [3.2. 函数占位参数](#32-函数占位参数)
  - [3.3. 函数重载](#33-函数重载)
    - [3.3.1. 函数重载的概述](#331-函数重载的概述)
    - [3.3.2. 函数重载的注意事项](#332-函数重载的注意事项)

## 1. 内存分区模型

c++ 程序在执行时，将内存大方向划分为 4 个区域

- 代码区：存放函数体的二进制代码
- 全局区：存放全局变量、静态变量以及常量
- 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等
- 堆区：由程序员分配释放。若程序员不释放，程序结束时由操作系统回收

### 1.1. 程序运行前

在程序编译 2 后，生成了 exe 可执行程序，未执行该程序前分为两个区域：

**代码区**：

- 存放 CPU 执行的机器指令
- 代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
- 代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

**全局区**：

- 全局变量和*静态*变量存放在此

  ```cpp
  static int a = 10;
  ```

- 全局区还包含了常量区，字符串常量和其他常量也存放在此
- 该区域的数据在程序结束后由操作系统释放

### 1.2. 程序运行后

**栈区**：
由编译器自动分配释放，存放函数的参数值、局部变量等
注意事项：不要返回局部变量的地址，栈区开辟的数据  由编译器自动释放

**堆区**:
由程序员分配释放。若程序员不释放，程序结束时由操作系统回收
C++ 中主要利用 new 在堆区开辟内存

```cpp
int* func()
{
  int* p = new int(10);
  return p;
}
int main()
{
  int* q = func();
  cout << *q << endl;
  return 0;
}
///
p在栈区，存储了10的地址；函数返回后销毁
10在堆区
///
```

### 1.3. new 操作符

C++ 中利用 new 操作符在堆区开辟数据
堆区开辟的数据，由程序员手动开辟、手动释放，释放利用操作符`delete`
> delete 是释放指针所指向的内容，而不是删除指针
>
利用 new 创建数据，会返回对应的指针
e.g. 在堆区利用 new 开辟数组：

```cpp
int* func()
{
  //创建一个包含10个'int型元素'的数组，里面每个元素默认值为0
  int* arr = new int[10];
  for (int i = 0; i < 10; i++)
  {
    arr[i] = i;
  }
  return arr;
}
//释放
//delete[] arr;
```

## 2. 引用

### 2.1. 引用的基本使用

作用：给变量起别名
语法：`数据类型 &别名 = 原名`

注意事项：

- 引用必须初始化
- 引用初始化后，不可以改变

### 2.2. 引用做函数参数

作用：函数传参时，可以利用引用的技术让形参修饰实参
优点：可以简化指针修改实参

```cpp
void swap(int& a, int& b)
{
  int temp = a;
  a = b;
  b = temp;
}
int main()
{
  int a = 10, b = 20;
  swap(a, b);
  cout << a << ' ' << b << endl;
  return 0;
}
```

### 2.3. 引用做函数返回值

注意：不要返回局部变量引用

```cpp
//错误示范
int& func()
{
  int a = 10;
  return a;
}
int main()
{
  int& b = func();
  cout << b << endl;//第一次结果正确是因为编译器做了保留
  cout << b << endl;
  return 0;
}

//正确用法
int& func()
{
    static int a = 10;//静态变量存放在全局区，不会在函数结束时被释放
    return a;
}
int main()
{
    int& b = func();
    cout << b << endl;
    cout << b << endl;
    return 0;
}
```

- 函数调用作为左值

```cpp
int& func()
{
    static int a = 10;
    return a;
}
int main()
{
    int& b = func();
    cout << b << endl;
    cout << b << endl;
    func() = 1000;//如果函数返回值是引用，这个函数调用可作为左值
    cout << b << endl;
    cout << b << endl;
    return 0;
}
```

### 2.4. 引用的本质

引用的本质在 C++ 内部实现是一个指针常量

```cpp
int& ref = a;
相当于
int* const ref = &a;
```

### 2.5. 常量引用

常量引用主要用来修饰形参，防止误操作
在函数形参列表中，可以加 const 修饰形参，防止形参改变实参

## 3. 函数提高

### 3.1. 函数默认参数

在 C++ 中，函数的形参列表中的形参是可以有默认值的

```cpp
int func(int a = 1, int b = 2, int c = 3)
{
  return a + b + c;
}
```

**注意事项**：

- 如果一个参数有了默认值，则这个参数之后的参数必须有默认值
- 如果函数**声明**有默认参数，则函数**实现**就不能有默认参数

### 3.2. 函数占位参数

函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置
占位参数也可以有默认参数

```cpp
void func(int = 10)
{
  cout << "this is func" << endl;
}
```

### 3.3. 函数重载

#### 3.3.1. 函数重载的概述

函数名可以相同，提高复用性
**函数重载满足条件**：

- 同一个作用域下
- 函数名称相同
- 函数参数**类型不同**或者**个数不同**或者**顺序不同**

注意：函数的返回值不可以作为函数重载的条件

#### 3.3.2. 函数重载的注意事项

- 引用作为重载条件

```cpp
void func(int& a)
void func(const int& a)
满足第三条，可以重载
```

- 函数重载碰到函数默认参数
  凡是无法区分的重载就会报错


